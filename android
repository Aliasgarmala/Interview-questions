To navigate transitions between stages of the activity lifecycle, the Activity class provides a core set of six callbacks:
onCreate(), onStart(), onResume(), onPause(), onStop(), and onDestroy().

onCreate() : you perform basic application startup logic that should happen only once for the entire life of the activity.
onStart() called when the activity is becoming visible to the user.
onResume() called when the activity will start interacting with the user.

By default, the system uses the Bundle instance state to save information about each View object when
the activity is destroyed and recreated.
To save additional data about the activity state, you must override the onSaveInstanceState() callback and
onRestoreInstanceState() and reuse LiveData and ViewModel is not destroyed

Implict vs explicit intent
Implicit intents do not declare the class name of the component to start, but instead declare an action to perform.
For eg: you will need and intentchooser or intent picker to and set the type of the app you are targeting
An intent that is used with sticky broadcast, is called as sticky intent.
This intent will stick with android system for future broadcast receiver requests. for eg: battery low. so future receiver
(dynamic) knows the battery is low and can take action accordingly. (It's deprecated now)

To advertise which implicit intents your app can receive, declare one or more intent filters for each of your app
components with an <intent-filter> element in your manifest file.

To allow other apps to start your activity, you need to add an <intent-filter> element in
your manifest file for the corresponding <activity> element with <action>, <data> and <category>
(which is normally defualt) element
setResult()  and startActivityForResult() if you want a result from the activity

A Handler is very convenient object to communicate between 2 threads (for instance : a background thread need to update the UI.

API 15: Android 4.0.3 (IceCreamSandwich) this cover approx 94.0% of devices that are active on google play store
You get this info when you create the new app in android studio.

How to make app for different screen sizes?
1. Always use dp (density independent pixels )units the base for this is medium density screen. 
for low & high the system scales
2. Provide alternative bit map resources for different densities. 
Place all your launcher icons in the res/mipmap-[density]/ folders,
rather than the res/drawable-[density]/ folders. 
the resources in drawable/ are the default drawable resources. you can also provide orientation qualifier
3. provide different layouts for different screen sizes

Sample-webrtc-web which is the SDK with QuickBlox use for video conferrencing 

Traceview tool to check the bottlenecks in the code and how much time a function is taking to execute.

Use tape library in android to upload images in the queue even when the network is flaky.
Try pressure testing your app by closing the process.

The Application class, or any subclass of the Application class, is instantiated before any other class when the 
process for your application/package is created.
uses of subclass of application
Global initialization that needs to be shared across all components (crash reporting, persistence)

What is a memory leak?
Some objects have a limited lifetime. When their job is done, they are expected to be garbage collected.
If a chain of references holds an object in memory after the end of its expected lifetime,
this creates a memory leak. When these leaks accumulate, the app runs out of memory.
Avoiding memory leaks 
use optimized data containers provided by android instead by Java for eg: 
SparseArray, SparseBooleanArra and if the activity is destroyed (device rotation) assign the listeners to null generated by
view
Leaving a service running when itâ€™s not needed is one of the worst memory-management mistakes

Read about View.onMeasure() and View.onLayout()

https://www.tutorialspoint.com/android/android_application_components.htm

call one class from another class 
Serialiazable and parcelable 
concurrent programming in android, race condition example, RxJava, caching in android, MVP vs MVVM
what is a bitmap
bitmap images (9 patch) automatically resize to accommodate the contents of the view and the size of the screen
Selected parts of the image are scaled horizontally or vertically based on indicators drawn within the image.
how to avoid race condition in android

The ViewModel class is designed to store and manage UI-related data in a lifecycle conscious way.
The ViewModel class allows data to survive configuration changes such as screen rotations.
Lifecycleowner object has a lifecycle object which tells you what state of lifecycle you're in and query
the state and put your code or attach an oberserver which has callbacks on appropriate lifecycles, 
this can be put independent of your activity
Only view and ViewModel in activities, LiveData tracks all the changes and handles lifecycle separately.
LiveData setValue is main thread post value is background thread
Room is local persistance for data
New paging library for recyclerview 

Dalvik is gone and replaced by ART (Android Runtime) has Ahead of time compilation, imrpobed GC,
improved debugging, improved crash reports

StrictMode is the API which should be used on App Application and in developer build so that it prevents accidental 
things like accidental things accessing network/disk on main thread

you may want to implement code to access an existing content provider in another application (content receiver),
or you may want to create a new content provider in your application to share data with other applications(content provider)

Shared pereferences is the place to store key value pair within the app context only and only primitive types allowed there
Handler is used to communicate from back ground thread to main thread through messages.

Intent services creates a default worker thread, Creates a work queue by deafult that passes one intent at a time to your 
onHandleIntent() implementation, so you never have to worry about multi-threading.
Stops the service after all of the start requests are handled, so you never have to call stopSelf().

Service OnStartCommand() is called when starting a new service. 
you should return START_STICKY in OnStartCommand (the system will try to re-create your service after it is killed)
START_NON_STICKY is system doesn't care. Since this runs on Main thread you need to create worker thread to do any non blocking
work. You need to stop the service explicitly. You can always communicate back to your activity using  BroadcastReceivers. 
A perfect ex is to play music player, where music is playing in the background 

Dependency Injection: Is a design pattern where you don't create the objects yourself but you let someone else create it.
