To navigate transitions between stages of the activity lifecycle, the Activity class provides a core set of six callbacks:
onCreate(), onStart(), onResume(), onPause(), onStop(), and onDestroy().

onCreate() : you perform basic application startup logic that should happen only once for the entire life of the activity.
onStart() called when the activity is becoming visible to the user.
onResume() called when the activity will start interacting with the user.

By default, the system uses the Bundle instance state to save information about each View object when
the activity is destroyed and recreated.
To save additional data about the activity state, you must override the onSaveInstanceState() callback and
onRestoreInstanceState() and reuse LiveData and ViewModel is not destroyed

Implict vs explicit intent
Implicit intents do not declare the class name of the component to start, but instead declare an action to perform.
For eg: you will need and intentchooser or intent picker to and set the type of the app you are targeting
An intent that is used with sticky broadcast, is called as sticky intent.
This intent will stick with android system for future broadcast receiver requests. for eg: battery low. so future receiver
(dynamic) knows the battery is low and can take action accordingly. (It's deprecated now)

To advertise which implicit intents your app can receive, declare one or more intent filters for each of your app
components with an <intent-filter> element in your manifest file.

To allow other apps to start your activity, you need to add an <intent-filter> element in
your manifest file for the corresponding <activity> element with <action>, <data> and <category>
(which is normally defualt) element
setResult()  and startActivityForResult() if you want a result from the activity

Beginning in Android 6.0 (API level 23), users grant permissions to apps while the app is running,
not when they install the app System permissions are divided into two categories,
normal and dangerous:Dangerous permissions can give the app access to the user's 
confidential data.

Best practice for runtime permission
You can explicitly ask permission to get the full control of the app you're using but this will add 
complexity as you have design the
UI. if the user doesn't grant the permission (or revokes it later on), your app becomes unable to 
perform the operation at all.
Quite often your app can avoid requesting a permission by using an intent instead

API 15: Android 4.0.3 (IceCreamSandwich) this cover approx 94.0% of devices that are active on google play store
You get this info when you create the new app in android studio.

How to make app for different screen sizes?
1. Always use dp (density independent pixels )units the base for this is medium density screen. 
for low & high the system scales
2. Provide alternative bit map resources for different densities. 
Place all your launcher icons in the res/mipmap-[density]/ folders,
rather than the res/drawable-[density]/ folders. 
the resources in drawable/ are the default drawable resources. you can also provide orientation qualifier
3. provide different layouts for different screen sizes

Sample-webrtc-web which is the SDK with QuickBlox use for video conferrencing 

Traceview tool to check the bottlenecks in the code and how much time a function is taking to execute.

Android operating system is a stack of software components which is roughly divided into five sections and 
four main layers.

Use tape library in android to upload images in the queue even when the network is flaky.
Try pressure testing your app by closing the process.

The Application class, or any subclass of the Application class, is instantiated before any other class when the 
process for your application/package is created.
uses of subclass of application
Global initialization that needs to be shared across all components (crash reporting, persistence)

What is a memory leak?
Some objects have a limited lifetime. When their job is done, they are expected to be garbage collected.
If a chain of references holds an object in memory after the end of its expected lifetime,
this creates a memory leak. When these leaks accumulate, the app runs out of memory.
Avoiding memory leaks 
use optimized data containers provided by android instead by Java for eg: 
SparseArray, SparseBooleanArra and if the activity is destroyed (device rotation) assign the listeners to null generated by
view
Leaving a service running when itâ€™s not needed is one of the worst memory-management mistakes
not to use enums 


Read about View.onMeasure() and View.onLayout()

https://www.tutorialspoint.com/android/android_application_components.htm

what happend on device orientation 
call one class from another class 
Serialiazable and parcelable 
concurrent programming in android, race condition example, RxJava, caching in android, MVP vs MVVM
what is a bitmap
bitmap images (9 patch) automatically resize to accommodate the contents of the view and the size of the screen
Selected parts of the image are scaled horizontally or vertically based on indicators drawn within the image.
how to avoid race condition in android

The ViewModel class is designed to store and manage UI-related data in a lifecycle conscious way.
The ViewModel class allows data to survive configuration changes such as screen rotations.
Lifecycleowner object has a lifecycle object which tells you what state of lifecycle you're in and query
the state and put your code or attach an oberserver which has callbacks on appropriate lifecycles, 
this can be put independent of your activity
Only view and ViewModel in activities, LiveData tracks all the changes and handles lifecycle separately.
Room is local persistance for data
New paging library for recyclerview 

Dalvik is gone and replaced by ART (Android Runtime) has Ahead of time compilation, imrpobed GC,
improved debugging, improved crash reports

StrictMode is the API which should be used on App Application and in developer build so that it prevents accidental 
things like accidental things accessing network/disk on main thread
